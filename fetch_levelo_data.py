#!/usr/bin/env python3
"""
Script de collecte des donn√©es Le V√©lo Marseille - VERSION OPTIMIS√âE
- R√©cup√®re les donn√©es depuis l'API GBFS Omega
- Sauvegarde dans Supabase (PostgreSQL) avec batch inserts
- Exporte en JSON pour le dashboard

Optimisations :
- Batch inserts (2 requ√™tes au lieu de 200+)
- Constantes pour les zones g√©ographiques
- Gestion am√©lior√©e de la capacit√© nulle
"""

import os
import json
import requests
from datetime import datetime
from supabase import create_client, Client

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# CONFIGURATION
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

# URLs de l'API Le V√©lo (GBFS Omega Fifteen)
BASE_URL = "https://gbfs.omega.fifteen.eu/gbfs/2.2/marseille/en"
STATION_STATUS_URL = f"{BASE_URL}/station_status.json"
STATION_INFO_URL = f"{BASE_URL}/station_information.json"

# Zones g√©ographiques de Marseille (latitude)
ZONE_NORD_LIMIT = 43.30
ZONE_CENTRE_LIMIT = 43.28

# Seuils de disponibilit√© pour les statuts
THRESHOLD_CRITICAL = 15
THRESHOLD_WARNING = 40
THRESHOLD_EXCELLENT = 70

# Configuration Supabase
SUPABASE_URL = os.environ.get("SUPABASE_URL")
SUPABASE_KEY = os.environ.get("SUPABASE_KEY")

# V√©rification des variables d'environnement
if not SUPABASE_URL or not SUPABASE_KEY:
    print("‚ùå Erreur : Variables SUPABASE_URL et SUPABASE_KEY requises")
    exit(1)

# Connexion √† Supabase
supabase: Client = create_client(SUPABASE_URL, SUPABASE_KEY)

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# FONCTIONS UTILITAIRES
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

def determine_zone(latitude: float) -> str:
    """
    D√©termine la zone g√©ographique en fonction de la latitude
    
    Args:
        latitude: Latitude de la station
        
    Returns:
        Nom de la zone (Nord/Centre/Sud Marseille)
    """
    if latitude >= ZONE_NORD_LIMIT:
        return 'Nord Marseille'
    elif latitude >= ZONE_CENTRE_LIMIT:
        return 'Centre Marseille'
    else:
        return 'Sud Marseille'

def calculate_status(bikes: int, capacity: int) -> str:
    """
    Calcule le statut d'affichage d'une station
    
    Args:
        bikes: Nombre de v√©los disponibles
        capacity: Capacit√© totale de la station
        
    Returns:
        Statut : critical, warning, good, excellent
    """
    if bikes == 0 or capacity == 0:
        return "critical"
    
    availability_rate = (bikes / capacity * 100)
    
    if availability_rate < THRESHOLD_CRITICAL:
        return "critical"
    elif availability_rate < THRESHOLD_WARNING:
        return "warning"
    elif availability_rate > THRESHOLD_EXCELLENT:
        return "excellent"
    else:
        return "good"

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# FONCTIONS PRINCIPALES
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

def fetch_api_data():
    """
    R√©cup√®re les donn√©es depuis l'API GBFS
    
    Returns:
        Tuple (status_data, info_data) ou (None, None) en cas d'erreur
    """
    print("üì° R√©cup√©ration des donn√©es API...")
    
    try:
        # R√©cup√©rer le statut des stations
        print(f"   ‚Üí {STATION_STATUS_URL}")
        status_response = requests.get(STATION_STATUS_URL, timeout=10)
        status_response.raise_for_status()
        status_data = status_response.json()['data']['stations']
        print(f"   ‚úÖ Stations status: {len(status_data)}")
        
        # R√©cup√©rer les infos des stations
        print(f"   ‚Üí {STATION_INFO_URL}")
        info_response = requests.get(STATION_INFO_URL, timeout=10)
        info_response.raise_for_status()
        info_data = info_response.json()['data']['stations']
        print(f"   ‚úÖ Stations info: {len(info_data)}")
        
        print("‚úÖ API accessible")
        return status_data, info_data
        
    except requests.exceptions.RequestException as e:
        print(f"‚ùå Erreur API : {e}")
        return None, None

def process_data(status_data, info_data):
    """
    Fusionne et nettoie les donn√©es
    Calcule les m√©triques (taux de disponibilit√©, statut)
    
    Args:
        status_data: Donn√©es de statut des stations
        info_data: Informations des stations
        
    Returns:
        Liste des enregistrements trait√©s
    """
    print("üîÑ Traitement des donn√©es...")
    
    # Cr√©er un dictionnaire des infos par station_id (O(N) au lieu de O(N¬≤))
    info_dict = {station['station_id']: station for station in info_data}
    
    processed = []
    
    for status in status_data:
        station_id = status['station_id']
        info = info_dict.get(station_id, {})
        
        # R√©cup√©rer les valeurs (avec gestion am√©lior√©e de la capacit√©)
        bikes = status.get('num_bikes_available', 0)
        stands = status.get('num_docks_available', 0)
        capacity = info.get('capacity', 0) or 0  # G√®re None et 0
        
        # Calculer le taux de disponibilit√©
        availability_rate = round((bikes / capacity * 100), 1) if capacity > 0 else 0.0
        
        # D√©terminer le statut d'affichage
        display_status = calculate_status(bikes, capacity)
        
        # Cr√©er l'enregistrement
        record = {
            'station_id': station_id,
            'station_name': info.get('name', 'Station inconnue'),
            'address': info.get('address', 'Adresse non disponible'),
            'latitude': info.get('lat', 0.0),
            'longitude': info.get('lon', 0.0),
            'available_bikes': bikes,
            'available_stands': stands,
            'total_capacity': capacity,
            'status': status.get('status', 'unknown'),
            'display_status': display_status,
            'availability_rate': availability_rate,
            'last_update': datetime.now().isoformat()
        }
        
        processed.append(record)
    
    print(f"‚úÖ {len(processed)} stations trait√©es")
    
    # Afficher un exemple pour debug
    if processed:
        example = processed[0]
        print(f"   üìç Exemple: {example['station_name']} - {example['available_bikes']}/{example['total_capacity']} v√©los")
    
    return processed

def save_to_supabase(data):
    """
    Sauvegarde dans Supabase avec batch inserts (OPTIMIS√â)
    
    Architecture :
    - stations_metadata : informations statiques (UPSERT batch)
    - levelo_observations : donn√©es dynamiques (INSERT batch)
    
    Args:
        data: Liste des enregistrements √† sauvegarder
        
    Returns:
        True si succ√®s, False sinon
    """
    print("üíæ Sauvegarde dans Supabase (batch inserts)...")
    
    # Pr√©parer les batches
    metadata_batch = []
    observations_batch = []
    
    for record in data:
        station_id = record['station_id']
        
        # D√©terminer la zone g√©ographique
        zone = determine_zone(record['latitude'])
        
        # Batch 1 : M√©tadonn√©es des stations
        metadata_batch.append({
            'station_id': station_id,
            'station_name': record['station_name'],
            'address': record['address'],
            'latitude': record['latitude'],
            'longitude': record['longitude'],
            'total_capacity': record['total_capacity'],
            'zone': zone,
            'updated_at': datetime.now().isoformat()
        })
        
        # Batch 2 : Observations
        observations_batch.append({
            'station_id': station_id,
            'available_bikes': record['available_bikes'],
            'available_stands': record['available_stands'],
            'status': record['status']
        })
    
    # Ex√©cuter les batch inserts
    saved_metadata = 0
    saved_observations = 0
    
    # 1. UPSERT batch metadata (1 seule requ√™te)
    try:
        print(f"   ‚Üí Upsert {len(metadata_batch)} m√©tadonn√©es...")
        supabase.table('stations_metadata').upsert(
            metadata_batch, 
            on_conflict='station_id'
        ).execute()
        saved_metadata = len(metadata_batch)
        print(f"   ‚úÖ {saved_metadata} m√©tadonn√©es mises √† jour")
    except Exception as e:
        print(f"   ‚ùå Erreur UPSERT batch metadata: {e}")
        return False
    
    # 2. INSERT batch observations (1 seule requ√™te)
    try:
        print(f"   ‚Üí Insert {len(observations_batch)} observations...")
        supabase.table('levelo_observations').insert(observations_batch).execute()
        saved_observations = len(observations_batch)
        print(f"   ‚úÖ {saved_observations} observations ins√©r√©es")
    except Exception as e:
        print(f"   ‚ùå Erreur INSERT batch observations: {e}")
        return False
    
    print(f"‚úÖ Sauvegarde termin√©e : {saved_metadata} stations, {saved_observations} observations")
    return True

def export_json(data):
    """
    Exporte les donn√©es en JSON pour le dashboard Dust
    
    Args:
        data: Liste des enregistrements √† exporter
        
    Returns:
        True si succ√®s, False sinon
    """
    print("üíæ Export JSON...")
    
    try:
        # Cr√©er le dossier data s'il n'existe pas
        os.makedirs('data', exist_ok=True)
        
        # Sauvegarder en JSON
        output_file = 'data/levelo_data.json'
        with open(output_file, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)
        
        # Calculer la taille du fichier
        file_size = os.path.getsize(output_file)
        file_size_kb = file_size / 1024
        
        print(f"‚úÖ JSON export√© : {len(data)} stations ({file_size_kb:.1f} KB)")
        print(f"   üìÅ Fichier : {output_file}")
        
        return True
        
    except Exception as e:
        print(f"‚ùå Erreur export JSON : {e}")
        return False

def main():
    """
    Fonction principale - Orchestration du workflow
    """
    print("=" * 70)
    print("üö¥ COLLECTE DONN√âES LE V√âLO MARSEILLE (VERSION OPTIMIS√âE)")
    print("=" * 70)
    print(f"‚è∞ D√©but : {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    print()
    
    # 1. R√©cup√©rer les donn√©es de l'API
    status_data, info_data = fetch_api_data()
    
    if not status_data or not info_data:
        print("‚ùå Impossible de r√©cup√©rer les donn√©es API")
        exit(1)
    
    # 2. Traiter les donn√©es
    processed_data = process_data(status_data, info_data)
    
    if not processed_data:
        print("‚ùå Aucune donn√©e √† traiter")
        exit(1)
    
    # 3. Sauvegarder dans Supabase (batch inserts)
    supabase_success = save_to_supabase(processed_data)
    
    if not supabase_success:
        print("‚ùå Erreur lors de la sauvegarde Supabase")
        exit(1)
    
    # 4. Exporter en JSON (pour le dashboard)
    json_success = export_json(processed_data)
    
    if not json_success:
        print("‚ö†Ô∏è  Erreur lors de l'export JSON (non bloquant)")
    
    # 5. R√©sum√©
    print()
    print("=" * 70)
    print("‚úÖ Collecte termin√©e avec succ√®s !")
    print(f"   üìä {len(processed_data)} stations trait√©es")
    print(f"   üíæ 2 requ√™tes SQL (batch inserts)")
    print(f"   üìÅ JSON export√©")
    print(f"‚è∞ Fin : {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    print("=" * 70)

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# POINT D'ENTR√âE
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

if __name__ == "__main__":
    main()
